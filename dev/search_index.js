var documenterSearchIndex = {"docs":
[{"location":"index.html#orbit","page":"Orbit transfer","title":"Minimum time orbit transfer","text":"","category":"section"},{"location":"index.html#Introduction","page":"Orbit transfer","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"<img src=\"./assets/cnes-tas.jpg\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"400px\">","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"Minimum time control of the Kepler equation (CNES / TAS / Inria / CNRS collaboration, check [1] and [2]):","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"begincases\n  t_f to min\n  ddotq = -mufracqq^3 + fracumquad t in 0t_f\n  dotm = -betauquad u leq T_mathrmmax\nendcases","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"Fixed initial and final Keplerian orbits (free final longitude).","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"<img src=\"./assets/orbit.jpg\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"400px\">","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"using OptimalControl\nusing NLPModelsIpopt\nusing OrdinaryDiffEq\nusing Plots\nusing MINPACK\nusing ForwardDiff\nusing LinearAlgebra","category":"page"},{"location":"index.html#Problem-definition","page":"Orbit transfer","title":"Problem definition","text":"","category":"section"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"Tmax = 60                                  # Maximum thrust in Newtons\ncTmax = 3600^2 / 1e6; T = Tmax * cTmax     # Conversion from Newtons to kg x Mm / h²\nmass0 = 1500                               # Initial mass of the spacecraft\nβ = 1.42e-02                               # Engine specific impulsion\nμ = 5165.8620912                           # Earth gravitation constant\nP0 = 11.625                                # Initial semilatus rectum\nex0, ey0 = 0.75, 0                         # Initial eccentricity\nhx0, hy0 = 6.12e-2, 0                      # Initial ascending node and inclination\nL0 = π                                     # Initial longitude\nPf = 42.165                                # Final semilatus rectum\nexf, eyf = 0, 0                            # Final eccentricity\nhxf, hyf = 0, 0                            # Final ascending node and inclination\n\nasqrt(x; ε=1e-9) = sqrt(sqrt(x^2+ε^2))     # Avoid issues with AD\n\nfunction F0(x)\n    P, ex, ey, hx, hy, L = x\n    pdm = asqrt(P / μ)\n    cl = cos(L)\n    sl = sin(L)\n    w = 1 + ex * cl + ey * sl\n    F = zeros(eltype(x), 6) # Use eltype to allow overloading for AD\n    F[6] = w^2 / (P * pdm)\n    return F\nend\n\nfunction F1(x)\n    P, ex, ey, hx, hy, L = x\n    pdm = asqrt(P / μ)\n    cl = cos(L)\n    sl = sin(L)\n    F = zeros(eltype(x), 6)\n    F[2] = pdm *   sl\n    F[3] = pdm * (-cl)\n    return F\nend\n\nfunction F2(x)\n    P, ex, ey, hx, hy, L = x\n    pdm = asqrt(P / μ)\n    cl = cos(L)\n    sl = sin(L)\n    w = 1 + ex * cl + ey * sl\n    F = zeros(eltype(x), 6)\n    F[1] = pdm * 2 * P / w\n    F[2] = pdm * (cl + (ex + cl) / w)\n    F[3] = pdm * (sl + (ey + sl) / w)\n    return F\nend\n\nfunction F3(x)\n    P, ex, ey, hx, hy, L = x\n    pdm = asqrt(P / μ)\n    cl = cos(L)\n    sl = sin(L)\n    w = 1 + ex * cl + ey * sl\n    pdmw = pdm / w\n    zz = hx * sl - hy * cl\n    uh = (1 + hx^2 + hy^2) / 2\n    F = zeros(eltype(x), 6)\n    F[2] = pdmw * (-zz * ey)\n    F[3] = pdmw *   zz * ex\n    F[4] = pdmw *   uh * cl\n    F[5] = pdmw *   uh * sl\n    F[6] = pdmw *   zz\n    return F\nend\n\nnothing # hide","category":"page"},{"location":"index.html#Direct-solve","page":"Orbit transfer","title":"Direct solve","text":"","category":"section"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"tf = 15                                      # Estimation of final time\nLf = 3π                                      # Estimation of final longitude\nx0 = [P0, ex0, ey0, hx0, hy0, L0]            # Initial state\nxf = [Pf, exf, eyf, hxf, hyf, Lf]            # Final state\nx(t) = x0 + (xf - x0) * t / tf               # Linear interpolation\nu(t) = [0.1, 0.5, 0.]                        # Initial guess for the control\nnlp_init = (state=x, control=u, variable=tf) # Initial guess for the NLP\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [0, tf], time\n    x = (P, ex, ey, hx, hy, L) ∈ R⁶, state\n    u ∈ R³, control\n    x(0) == x0 \n    x[1:5](tf) == xf[1:5]\n    mass = mass0 - β * T * t\n    ẋ(t) == F0(x(t)) + T / mass * (u₁(t) * F1(x(t)) + u₂(t) * F2(x(t)) + u₃(t) * F3(x(t)))\n    u₁(t)^2 + u₂(t)^2 + u₃(t)^2 ≤ 1\n    tf → min\nend","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"nlp_sol = OptimalControl.solve(ocp; init=nlp_init, grid_size=100)\nnothing # hide","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"tf = nlp_sol.variable\np0 = nlp_sol.costate(0)\nplot(nlp_sol)","category":"page"},{"location":"index.html#Shooting-(1/2),-Tmax-60-Newtons","page":"Orbit transfer","title":"Shooting (1/2), Tmax = 60 Newtons","text":"","category":"section"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"function ur(t, x, p, tf) # Regular maximising control \n    H1 = p' * F1(x)\n    H2 = p' * F2(x)\n    H3 = p' * F3(x)\n    u = [H1, H2, H3]\n    u = u / sqrt(u[1]^2 + u[2]^2 + u[3]^2)\n    return u\nend\n\nfr = Flow(ocp, ur) # Regular flow (first version)\n\nfunction shoot(ξ::Vector{T}) where T\n    tf, p0 = ξ[1], ξ[2:end]\n    xf_, pf = fr(0, x0, p0, tf)\n    s = zeros(T, 7)\n    s[1:5] = xf_[1:5] - xf[1:5]\n    s[6] = pf[6]\n    s[7] = p0[1]^2 + p0[2]^2 + p0[3]^2 + p0[4]^2 + p0[5]^2 + p0[6]^2 - 1\n    return s\nend\n\np0 = p0 / norm(p0) # Normalization |p0|=1 for free final time\nξ = [tf; p0]; # Initial guess\njshoot(ξ) = ForwardDiff.jacobian(shoot, ξ)\nshoot!(s, ξ) = (s[:] = shoot(ξ); nothing)\njshoot!(js, ξ) = (js[:] = jshoot(ξ); nothing)\nbvp_sol = fsolve(shoot!, jshoot!, ξ; show_trace=true); println(bvp_sol)\nnothing # hide","category":"page"},{"location":"index.html#Shooting-(2/2),-Tmax-0.7-Newtons","page":"Orbit transfer","title":"Shooting (2/2), Tmax = 0.7 Newtons","text":"","category":"section"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"hr = (t, x, p) -> begin # Regular maximised Hamiltonian (more efficient)\n    H0 = p' * F0(x)\n    H1 = p' * F1(x)\n    H2 = p' * F2(x)\n    H3 = p' * F3(x)\n    mass = mass0 - β*T*t\n    h = H0 + T / mass * sqrt(H1^2 + H2^2 + H3^2) \n    return h\nend\n\nhr = Hamiltonian(hr; autonomous=false)\nfr = Flow(hr) # Regular flow (again)\n\nTmax = 0.7                                 # Maximum thrust (Newtons)\ncTmax = 3600^2 / 1e6; T = Tmax * cTmax     # Conversion from Newtons to kg x Mm / h²\ntf = 6.080e3; p0 =-[-1.234155379067110e+02, -6.207170881591489e+02, 5.742554220129187e-01, 1.629324243017332e+03, -2.373935935351530e+00, -2.854066853269850e-01] # hide\ntf = 1.320e2; p0 =-[-4.743728539366440e+00, -7.171314869854240e+01, -2.750468309804530e+00, 4.505679923365745e+01, -3.026794475592510e+00, 2.248091067047670e+00] # hide\ntf = 1.210e3; p0 =-[-2.215319700438820e+01, -4.347109477345140e+01, 9.613188807286992e-01, 3.181800985503019e+02, -2.307236094862410e+00, -5.797863110671591e-01] # Tmax = 0.7 Newtons \np0 = p0 / norm(p0) # Normalization |p0|=1 for free final time\nξ = [tf; p0]; # Initial guess\n\nbvp_sol = fsolve(shoot!, jshoot!, ξ; show_trace=true); println(bvp_sol)\nnothing # hide","category":"page"},{"location":"index.html#Plots","page":"Orbit transfer","title":"Plots","text":"","category":"section"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"tf = bvp_sol.x[1]\np0 = bvp_sol.x[2:end]\node_sol = fr((0, tf), x0, p0)\nt  = ode_sol.t; N = size(t, 1)\nP  = ode_sol[1, :]\nex = ode_sol[2, :]\ney = ode_sol[3, :]\nhx = ode_sol[4, :]\nhy = ode_sol[5, :]\nL  = ode_sol[6, :]\ncL = cos.(L)\nsL = sin.(L)\nw  = @. 1 + ex * cL + ey * sL\nZ  = @. hx * sL - hy * cL\nC  = @. 1 + hx^2 + hy^2\nq1 = @. P *((1 + hx^2 - hy^2) * cL + 2 * hx * hy * sL) / (C * w)\nq2 = @. P *((1 - hx^2 + hy^2) * sL + 2 * hx * hy * cL) / (C * w)\nq3 = @. 2 * P * Z / (C * w)\n\nplt1 = plot3d(1; xlim = (-60, 60), ylim = (-60, 60), zlim = (-5, 5), title = \"Orbit transfer\", legend=false)\n@gif for i = 1:N\n    push!(plt1, q1[i], q2[i], q3[i])\nend every N ÷ min(N, 100) ","category":"page"},{"location":"index.html#References","page":"Orbit transfer","title":"References","text":"","category":"section"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"[1]: Bonnard, B.; Caillau, J.-B.; Trélat, E. Geometric optimal control of elliptic Keplerian orbits.  Discrete Contin. Dyn. Syst. Ser. B 5 (2005), no. 4, 929-956.","category":"page"},{"location":"index.html","page":"Orbit transfer","title":"Orbit transfer","text":"[2]: Caillau, J.-B.; Gergaud, J.; Noailles, J. 3D Geosynchronous Transfer of a Satellite: continuation on the Thrust. J. Optim. Theory Appl. 118 (2003), no. 3, 541-565.","category":"page"}]
}
